# 1. Udacity Term 2 Project 5 Writeup  
The project was frustrating but inspiring. Like many others, I wonder how much I contributed in doing this project. This would have been very difficult-- nearly impossible-- without the quiz and the q&a. However, the problem shown has piqued my curiosity about the mathematical problems that might be solved with ipopt and non-convex optimization in general: the forms that may be expressed in the program have very few limitations as long as the dynamics can be expressed by differentiable functions.   

The project was very difficult because the packages and the iterative steps made it difficult to debug. Moreover, transformations needed to simplify the project were far removed from the project description, taking a bit of an imaginative leap. The first step of transforming the global coordinate system to the car's coordinate system was not intuitive for me. The subsequent simplifications that came out of this transformation were satisfying to see but did not extend naturally from the lessons.  

With little familiarity with the iopt package, it was essentially a black box and it was hard to distinguish where in your code the bug was occurring. In my case, the issue was not in the code itself but with my computer. After a few frustrating days, I found that no matter what I did, if my computer was hot, the car would take a sharp turn left. Once I reinstalled my operating system, changes to the parameters began to make a difference.  

### The problems solved within this project are as follows:  

	#### 1. The structure of the code. At each time step, you receive a trajectory and measurements of the vehicle's velocity and position. You must output a throttle and steer angle. The steps here are to take the global trajectory and position coordinates and transform them to the vehicle's coordinate system. You then adjust for latency, the period between when the measurement was made and the action that will be taken. Then using the iopt package find the actions (throttle and steer angle) that minimize error over the next N time steps. Then we take the most immediate action. The error will be described in more detail below.  
	#### 1. Tuning the components of the cost function. The primary components of the cost function are path deviation error (cte) angular error(epsi). Cte is the distance the car is away from the given trajectory. Epsi is the deviation in radians away from the heading of the trajectory. Both these terms were included as squared errors and obvious received the most weight in the cost function. Other terms were included to give desirable characteristics to the output of the algorithm. 1. squared magnitude of throttle and steering angle. The intuition for these terms is that since the car's trajectory is continuous, there will be no large accelerations or steering. 2. throttle and accelerations must be close to one-another in each time step. Similar to the previous restriction, this means that the throttle and acceleration must also change smoothly between time steps so that there are no sudden changes in action. Again this is a fact that comes from the car's smooth trajectory. This set of parameters was the second most important. Really, the steering angle was the most important term here.  
	#### 1. Dynamics constraints were the last problem solved. These were defined clearly in the lesson, but were non-trivial. They describe how acceleration and steering angle, combined with velocity affect the position, velocity, and acceleration of the vehicle.   

Most of the time on this project was spent tuning the weights for the components of the cost function. As expected, the cte and epsi terms were the most important as they guarantee the car stays on the track. After some experimentation, I found weights similar to those used in the q&a. Other parameters that made a difference were N and dt. These described how long a time step was and how many timesteps to optimize over. Usually N can be pretty small, but if the trajectory is highly curved and the car is traveling quickly, this could cause issues. dt was more interesting. If dt was small and N wasn't large enough to account for the short time horizon, the car's trajectory became very wobbly. But if dt was too large, the optimizer performed poorly at curves. I found that dt=0.1 was problematic with N=20 and produced an oscillating action. This led me to try dt=0.2, which led to poor performance on curves. Subsequently, I tried dt=0.15 and settled at dt=0.16. 

Now, to describe the dynamic constraints, these take a perspective of the simulation as one where one adds differentials to the previous state to describe the next state. For example the next x coordinate is equal to the current x coordinate plus the velocity in the x direction multiplied by time elapsed. The throttle can then be used to update the velocity terms and the steering angle term can be used to change the theta or heading term. 

Another problem solved in the project was that of the delay between measurements or latency. This was solved by simply assuming the car moved as would be expected by the dynamics. This way, the actual position of the car did not deviate from the internal position by as much.  


